{"version":3,"file":"static/js/718.086dd351.chunk.js","mappings":"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","sources":["webpack://my-app/./src/components/Pagination/Pagination.module.css?4da5","assets/img/arrow_next.svg","components/Pagination/Pagination.jsx","webpack://my-app/./src/components/Users/User/User.module.css?cfea","components/Users/User/User.jsx","components/Users/UsersInContainer.jsx","../node_modules/reselect/src/utils.ts","../node_modules/reselect/src/autotrackMemoize/proxy.ts","../node_modules/reselect/src/weakMapMemoize.ts","../node_modules/reselect/src/createSelectorCreator.ts","../node_modules/reselect/src/createStructuredSelector.ts","redux/users-selectors.js","components/Users/UsersContainerClass.jsx","webpack://my-app/./src/components/Users/Users.module.css?b9d0"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"pagination\":\"Pagination_pagination__vcNDC\",\"pagination__item\":\"Pagination_pagination__item__ttRTG\",\"pagination__item--active\":\"Pagination_pagination__item--active__INs0r\",\"pagination__arrow\":\"Pagination_pagination__arrow__OhTwl\",\"pagination__arrow--prev\":\"Pagination_pagination__arrow--prev__j1sDx\"};","var _g;\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nimport * as React from \"react\";\nfunction SvgArrowNext(_ref, svgRef) {\n  let {\n    title,\n    titleId,\n    ...props\n  } = _ref;\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    xmlns: \"http://www.w3.org/2000/svg\",\n    xmlnsXlink: \"http://www.w3.org/1999/xlink\",\n    width: 512,\n    height: 512,\n    x: 0,\n    y: 0,\n    viewBox: \"0 0 240.823 240.823\",\n    style: {\n      enableBackground: \"new 0 0 512 512\"\n    },\n    xmlSpace: \"preserve\",\n    className: \"\",\n    ref: svgRef,\n    \"aria-labelledby\": titleId\n  }, props), title ? /*#__PURE__*/React.createElement(\"title\", {\n    id: titleId\n  }, title) : null, _g || (_g = /*#__PURE__*/React.createElement(\"g\", null, /*#__PURE__*/React.createElement(\"path\", {\n    d: \"M183.189 111.816 74.892 3.555c-4.752-4.74-12.451-4.74-17.215 0-4.752 4.74-4.752 12.439 0 17.179l99.707 99.671-99.695 99.671c-4.752 4.74-4.752 12.439 0 17.191 4.752 4.74 12.463 4.74 17.215 0l108.297-108.261c4.68-4.691 4.68-12.511-.012-17.19z\",\n    fill: \"#000000\",\n    opacity: 1,\n    \"data-original\": \"#000000\",\n    className: \"\"\n  }))));\n}\nconst ForwardRef = /*#__PURE__*/React.forwardRef(SvgArrowNext);\nexport default __webpack_public_path__ + \"static/media/arrow_next.ba66ee1f9689f1767ef2bb9e4e8c3cc4.svg\";\nexport { ForwardRef as ReactComponent };","import classes from './Pagination.module.css';\nimport arrowNext from \"../../assets/img/arrow_next.svg\";\nimport React from \"react\";\n\nconst Pagination = (props)=>{\n    // Определяем видимые страницы\n    let startPage = Math.max(props.currentPage - 4, 1);\n    let endPage = Math.min(startPage + props.itemsPerPage - 1, props.pagesCount);\n\n    // Корректируем начало, если конец больше общего числа страниц\n    if (endPage - startPage < props.itemsPerPage - 1) {\n        startPage = Math.max(endPage - props.itemsPerPage + 1, 1);\n    }\n\n    let pages = [];\n    for (let i=startPage; i<=endPage; i++) {\n        pages.push(i);\n    }\n\n    return (\n        <div className={classes.pagination}>\n            {props.pagesCount > 9 &&\n            <button className={`${classes.pagination__item} ${classes.pagination__arrow} ${classes['pagination__arrow--prev']}`}\n                    onClick={() => {\n                        props.changePage(props.currentPage - 1)\n                    }}\n                    disabled={props.currentPage < 2 ? true : false} >\n                <img src={arrowNext} alt=\"Назад\"/>\n            </button>\n            }\n\n            {\n                pages.map((page, index) => {\n                    return (\n                        <span key={page}\n                              className={props.currentPage === page ? `${classes.pagination__item} ${classes['pagination__item--active']}` : classes.pagination__item}\n                              onClick={() => {\n                                  props.changePage(page)\n                              }}>\n                                    {page}\n                                </span>\n                    )\n                })\n            }\n\n            {props.pagesCount > props.itemsPerPage &&\n            <button\n                className={`${classes.pagination__item} ${classes.pagination__arrow} ${classes['pagination__arrow--next']}`}\n                onClick={() => {\n                    props.changePage(props.currentPage + 1)\n                }}\n                disabled={props.currentPage === props.pagesCount ? true : false} >\n                <img src={arrowNext} alt=\"Далее\"/>\n            </button>\n            }\n        </div>\n    )\n};\n\nexport default Pagination;","// extracted by mini-css-extract-plugin\nexport default {\"user\":\"User_user__fnnmF\",\"user__aside\":\"User_user__aside__9iv8D\",\"user__img\":\"User_user__img__AiIlB\",\"user__button\":\"User_user__button__K8cWr\",\"user__button--active\":\"User_user__button--active__QE7SE\",\"user__info\":\"User_user__info__oayEH\",\"user__link\":\"User_user__link__ThUFU\",\"user__data\":\"User_user__data__bMaTF\",\"user__name\":\"User_user__name__mn9q5\",\"user__status\":\"User_user__status__FtfPl\",\"user__location\":\"User_user__location__mekM-\"};","import {NavLink} from \"react-router-dom\";\n\nimport classes from \"./User.module.css\";\nimport userPhoto from '../../../assets/img/channels4_profile.jpg';\n\nconst User = (props) => {\n    const user = props.user;\n\n    const followUser = ()=>{\n        props.followUserThunk(user.id);\n    };\n\n    const unfollowUser = ()=>{\n        props.unfollowUserThunk(user.id);\n    };\n\n    return (\n        <div className={classes.user}>\n            <div className={classes.user__aside}>\n                <NavLink to={'/profile/' + user.id}>\n                    <div className={classes.user__img}>\n                    {/*Для внешнего запроса*/}\n                    <img src={user.photos.small ? user.photos.small : userPhoto} alt=\"\"/>\n\n                    {/*Для внутреннего запроса на users.json*/}\n                    {/*<img src={user.img ? user.img : userPhoto} alt={user.name}/>*/}\n                </div>\n                </NavLink>\n                <button onClick={user.followed ? unfollowUser : followUser}\n                        className={user.followed ? `${classes.user__button} ${classes['user__button--active']}` : `${classes.user__button}`}\n                        disabled={props.followingInProcess.some(id => id === user.id)}>\n                    {user.followed ? 'Unfollow' : 'Follow'}\n                </button>\n            </div>\n            <div className={classes.user__info}>\n                <NavLink to={'/profile/' + user.id} className={classes.user__link}>\n                    <div className={classes.user__data}>\n                        <p className={classes.user__name}>{user.name}</p>\n                        <p className={classes.user__status}>{user.status}</p>\n                    </div>\n                    <div className={classes.user__location}>\n                        {/*Для внешнего запроса*/}\n                        <p>Россия, Нижний Новгород</p>\n\n                        {/*Для внутреннего запроса на users.json*/}\n                        {/*<p>{`${user.location.country}, ${user.location.city}`}</p>*/}\n                    </div>\n                </NavLink>\n            </div>\n        </div>\n    )\n};\n\nexport default User;","import React from \"react\";\n\nimport classes from \"./Users.module.css\";\n\nimport User from \"./User/User\";\nimport Pagination from \"../Pagination/Pagination\";\nimport Loader from \"../common/Loader/Loader\";\n\n\nconst UsersInContainer = (props)=>{\n    const pagesCount = Math.ceil(props.totalUsersCount / props.pageSize);\n    const itemsPerPage = 9;\n\n    return (\n        <div>\n            <div className={classes.users_head}>\n                <h1>Users</h1>\n            </div>\n            <div className={classes.user_wrap}>\n                <div className={props.isFetching ? `${classes.users_list} ${classes[\"users_list--loading\"]}` : classes.users_list}>\n                    {\n                        props.users.map((user)=> {\n                            return (\n                                <User key={user.id}\n                                      user={user}\n                                      follow={props.follow}\n                                      unfollow={props.unfollow}\n                                      setFollowingStatus={props.setFollowingStatus}\n                                      followingInProcess={props.followingInProcess}\n                                      followUserThunk={props.followUserThunk}\n                                      unfollowUserThunk={props.unfollowUserThunk}/>\n                            )\n                        })\n                    }\n                </div>\n                {props.isFetching && <Loader parent='user_loading'/>}\n                <Pagination pagesCount={pagesCount} currentPage={props.currentPage} itemsPerPage={itemsPerPage} changePage={props.onPageChange}/>\n            </div>\n\n        </div>\n    )\n};\n\nexport default UsersInContainer;","import { runIdentityFunctionCheck } from './devModeChecks/identityFunctionCheck'\r\nimport { runInputStabilityCheck } from './devModeChecks/inputStabilityCheck'\r\nimport { globalDevModeChecks } from './devModeChecks/setGlobalDevModeChecks'\r\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\r\nimport type {\r\n  DevModeChecks,\r\n  Selector,\r\n  SelectorArray,\r\n  DevModeChecksExecutionInfo\r\n} from './types'\r\n\r\nexport const NOT_FOUND = /* @__PURE__ */ Symbol('NOT_FOUND')\r\nexport type NOT_FOUND_TYPE = typeof NOT_FOUND\r\n\r\n/**\r\n * Assert that the provided value is a function. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param func - The value to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsFunction<FunctionType extends Function>(\r\n  func: unknown,\r\n  errorMessage = `expected a function, instead received ${typeof func}`\r\n): asserts func is FunctionType {\r\n  if (typeof func !== 'function') {\r\n    throw new TypeError(errorMessage)\r\n  }\r\n}\r\n\r\n/**\r\n * Assert that the provided value is an object. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param object - The value to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsObject<ObjectType extends Record<string, unknown>>(\r\n  object: unknown,\r\n  errorMessage = `expected an object, instead received ${typeof object}`\r\n): asserts object is ObjectType {\r\n  if (typeof object !== 'object') {\r\n    throw new TypeError(errorMessage)\r\n  }\r\n}\r\n\r\n/**\r\n * Assert that the provided array is an array of functions. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param array - The array to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsArrayOfFunctions<FunctionType extends Function>(\r\n  array: unknown[],\r\n  errorMessage = `expected all items to be functions, instead received the following types: `\r\n): asserts array is FunctionType[] {\r\n  if (\r\n    !array.every((item): item is FunctionType => typeof item === 'function')\r\n  ) {\r\n    const itemTypes = array\r\n      .map(item =>\r\n        typeof item === 'function'\r\n          ? `function ${item.name || 'unnamed'}()`\r\n          : typeof item\r\n      )\r\n      .join(', ')\r\n    throw new TypeError(`${errorMessage}[${itemTypes}]`)\r\n  }\r\n}\r\n\r\n/**\r\n * Ensure that the input is an array. If it's already an array, it's returned as is.\r\n * If it's not an array, it will be wrapped in a new array.\r\n *\r\n * @param item - The item to be checked.\r\n * @returns An array containing the input item. If the input is already an array, it's returned without modification.\r\n */\r\nexport const ensureIsArray = (item: unknown) => {\r\n  return Array.isArray(item) ? item : [item]\r\n}\r\n\r\n/**\r\n * Extracts the \"dependencies\" / \"input selectors\" from the arguments of `createSelector`.\r\n *\r\n * @param createSelectorArgs - Arguments passed to `createSelector` as an array.\r\n * @returns An array of \"input selectors\" / \"dependencies\".\r\n * @throws A `TypeError` if any of the input selectors is not function.\r\n */\r\nexport function getDependencies(createSelectorArgs: unknown[]) {\r\n  const dependencies = Array.isArray(createSelectorArgs[0])\r\n    ? createSelectorArgs[0]\r\n    : createSelectorArgs\r\n\r\n  assertIsArrayOfFunctions<Selector>(\r\n    dependencies,\r\n    `createSelector expects all input-selectors to be functions, but received the following types: `\r\n  )\r\n\r\n  return dependencies as SelectorArray\r\n}\r\n\r\n/**\r\n * Runs each input selector and returns their collective results as an array.\r\n *\r\n * @param dependencies - An array of \"dependencies\" or \"input selectors\".\r\n * @param inputSelectorArgs - An array of arguments being passed to the input selectors.\r\n * @returns An array of input selector results.\r\n */\r\nexport function collectInputSelectorResults(\r\n  dependencies: SelectorArray,\r\n  inputSelectorArgs: unknown[] | IArguments\r\n) {\r\n  const inputSelectorResults = []\r\n  const { length } = dependencies\r\n  for (let i = 0; i < length; i++) {\r\n    // @ts-ignore\r\n    // apply arguments instead of spreading and mutate a local list of params for performance.\r\n    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs))\r\n  }\r\n  return inputSelectorResults\r\n}\r\n\r\n/**\r\n * Retrieves execution information for development mode checks.\r\n *\r\n * @param devModeChecks - Custom Settings for development mode checks. These settings will override the global defaults.\r\n * @param firstRun - Indicates whether it is the first time the selector has run.\r\n * @returns  An object containing the execution information for each development mode check.\r\n */\r\nexport const getDevModeChecksExecutionInfo = (\r\n  firstRun: boolean,\r\n  devModeChecks: Partial<DevModeChecks>\r\n) => {\r\n  const { identityFunctionCheck, inputStabilityCheck } = {\r\n    ...globalDevModeChecks,\r\n    ...devModeChecks\r\n  }\r\n  return {\r\n    identityFunctionCheck: {\r\n      shouldRun:\r\n        identityFunctionCheck === 'always' ||\r\n        (identityFunctionCheck === 'once' && firstRun),\r\n      run: runIdentityFunctionCheck\r\n    },\r\n    inputStabilityCheck: {\r\n      shouldRun:\r\n        inputStabilityCheck === 'always' ||\r\n        (inputStabilityCheck === 'once' && firstRun),\r\n      run: runInputStabilityCheck\r\n    }\r\n  } satisfies DevModeChecksExecutionInfo\r\n}\r\n","// Original source:\r\n// - https://github.com/simonihmig/tracked-redux/blob/master/packages/tracked-redux/src/-private/proxy.ts\r\n\r\nimport type { Node, Tag } from './tracking'\r\nimport {\r\n  consumeCollection,\r\n  consumeTag,\r\n  createTag,\r\n  dirtyCollection,\r\n  dirtyTag\r\n} from './tracking'\r\n\r\nexport const REDUX_PROXY_LABEL = Symbol()\r\n\r\nlet nextId = 0\r\n\r\nconst proto = Object.getPrototypeOf({})\r\n\r\nclass ObjectTreeNode<T extends Record<string, unknown>> implements Node<T> {\r\n  proxy: T = new Proxy(this, objectProxyHandler) as unknown as T\r\n  tag = createTag()\r\n  tags = {} as Record<string, Tag>\r\n  children = {} as Record<string, Node>\r\n  collectionTag = null\r\n  id = nextId++\r\n\r\n  constructor(public value: T) {\r\n    this.value = value\r\n    this.tag.value = value\r\n  }\r\n}\r\n\r\nconst objectProxyHandler = {\r\n  get(node: Node, key: string | symbol): unknown {\r\n    function calculateResult() {\r\n      const { value } = node\r\n\r\n      const childValue = Reflect.get(value, key)\r\n\r\n      if (typeof key === 'symbol') {\r\n        return childValue\r\n      }\r\n\r\n      if (key in proto) {\r\n        return childValue\r\n      }\r\n\r\n      if (typeof childValue === 'object' && childValue !== null) {\r\n        let childNode = node.children[key]\r\n\r\n        if (childNode === undefined) {\r\n          childNode = node.children[key] = createNode(childValue)\r\n        }\r\n\r\n        if (childNode.tag) {\r\n          consumeTag(childNode.tag)\r\n        }\r\n\r\n        return childNode.proxy\r\n      } else {\r\n        let tag = node.tags[key]\r\n\r\n        if (tag === undefined) {\r\n          tag = node.tags[key] = createTag()\r\n          tag.value = childValue\r\n        }\r\n\r\n        consumeTag(tag)\r\n\r\n        return childValue\r\n      }\r\n    }\r\n    const res = calculateResult()\r\n    return res\r\n  },\r\n\r\n  ownKeys(node: Node): ArrayLike<string | symbol> {\r\n    consumeCollection(node)\r\n    return Reflect.ownKeys(node.value)\r\n  },\r\n\r\n  getOwnPropertyDescriptor(\r\n    node: Node,\r\n    prop: string | symbol\r\n  ): PropertyDescriptor | undefined {\r\n    return Reflect.getOwnPropertyDescriptor(node.value, prop)\r\n  },\r\n\r\n  has(node: Node, prop: string | symbol): boolean {\r\n    return Reflect.has(node.value, prop)\r\n  }\r\n}\r\n\r\nclass ArrayTreeNode<T extends Array<unknown>> implements Node<T> {\r\n  proxy: T = new Proxy([this], arrayProxyHandler) as unknown as T\r\n  tag = createTag()\r\n  tags = {}\r\n  children = {}\r\n  collectionTag = null\r\n  id = nextId++\r\n\r\n  constructor(public value: T) {\r\n    this.value = value\r\n    this.tag.value = value\r\n  }\r\n}\r\n\r\nconst arrayProxyHandler = {\r\n  get([node]: [Node], key: string | symbol): unknown {\r\n    if (key === 'length') {\r\n      consumeCollection(node)\r\n    }\r\n\r\n    return objectProxyHandler.get(node, key)\r\n  },\r\n\r\n  ownKeys([node]: [Node]): ArrayLike<string | symbol> {\r\n    return objectProxyHandler.ownKeys(node)\r\n  },\r\n\r\n  getOwnPropertyDescriptor(\r\n    [node]: [Node],\r\n    prop: string | symbol\r\n  ): PropertyDescriptor | undefined {\r\n    return objectProxyHandler.getOwnPropertyDescriptor(node, prop)\r\n  },\r\n\r\n  has([node]: [Node], prop: string | symbol): boolean {\r\n    return objectProxyHandler.has(node, prop)\r\n  }\r\n}\r\n\r\nexport function createNode<T extends Array<unknown> | Record<string, unknown>>(\r\n  value: T\r\n): Node<T> {\r\n  if (Array.isArray(value)) {\r\n    return new ArrayTreeNode(value)\r\n  }\r\n\r\n  return new ObjectTreeNode(value) as Node<T>\r\n}\r\n\r\nconst keysMap = new WeakMap<\r\n  Array<unknown> | Record<string, unknown>,\r\n  Set<string>\r\n>()\r\n\r\nexport function updateNode<T extends Array<unknown> | Record<string, unknown>>(\r\n  node: Node<T>,\r\n  newValue: T\r\n): void {\r\n  const { value, tags, children } = node\r\n\r\n  node.value = newValue\r\n\r\n  if (\r\n    Array.isArray(value) &&\r\n    Array.isArray(newValue) &&\r\n    value.length !== newValue.length\r\n  ) {\r\n    dirtyCollection(node)\r\n  } else {\r\n    if (value !== newValue) {\r\n      let oldKeysSize = 0\r\n      let newKeysSize = 0\r\n      let anyKeysAdded = false\r\n\r\n      for (const _key in value) {\r\n        oldKeysSize++\r\n      }\r\n\r\n      for (const key in newValue) {\r\n        newKeysSize++\r\n        if (!(key in value)) {\r\n          anyKeysAdded = true\r\n          break\r\n        }\r\n      }\r\n\r\n      const isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize\r\n\r\n      if (isDifferent) {\r\n        dirtyCollection(node)\r\n      }\r\n    }\r\n  }\r\n\r\n  for (const key in tags) {\r\n    const childValue = (value as Record<string, unknown>)[key]\r\n    const newChildValue = (newValue as Record<string, unknown>)[key]\r\n\r\n    if (childValue !== newChildValue) {\r\n      dirtyCollection(node)\r\n      dirtyTag(tags[key], newChildValue)\r\n    }\r\n\r\n    if (typeof newChildValue === 'object' && newChildValue !== null) {\r\n      delete tags[key]\r\n    }\r\n  }\r\n\r\n  for (const key in children) {\r\n    const childNode = children[key]\r\n    const newChildValue = (newValue as Record<string, unknown>)[key]\r\n\r\n    const childValue = childNode.value\r\n\r\n    if (childValue === newChildValue) {\r\n      continue\r\n    } else if (typeof newChildValue === 'object' && newChildValue !== null) {\r\n      updateNode(childNode, newChildValue as Record<string, unknown>)\r\n    } else {\r\n      deleteNode(childNode)\r\n      delete children[key]\r\n    }\r\n  }\r\n}\r\n\r\nfunction deleteNode(node: Node): void {\r\n  if (node.tag) {\r\n    dirtyTag(node.tag, null)\r\n  }\r\n  dirtyCollection(node)\r\n  for (const key in node.tags) {\r\n    dirtyTag(node.tags[key], null)\r\n  }\r\n  for (const key in node.children) {\r\n    deleteNode(node.children[key])\r\n  }\r\n}\r\n","// Original source:\r\n// - https://github.com/facebook/react/blob/0b974418c9a56f6c560298560265dcf4b65784bc/packages/react/src/ReactCache.js\r\n\r\nimport type {\r\n  AnyFunction,\r\n  DefaultMemoizeFields,\r\n  EqualityFn,\r\n  Simplify\r\n} from './types'\r\n\r\nclass StrongRef<T> {\r\n  constructor(private value: T) {}\r\n  deref() {\r\n    return this.value\r\n  }\r\n}\r\n\r\nconst Ref =\r\n  typeof WeakRef !== 'undefined'\r\n    ? WeakRef\r\n    : (StrongRef as unknown as typeof WeakRef)\r\n\r\nconst UNTERMINATED = 0\r\nconst TERMINATED = 1\r\n\r\ninterface UnterminatedCacheNode<T> {\r\n  /**\r\n   * Status, represents whether the cached computation returned a value or threw an error.\r\n   */\r\n  s: 0\r\n  /**\r\n   * Value, either the cached result or an error, depending on status.\r\n   */\r\n  v: void\r\n  /**\r\n   * Object cache, a `WeakMap` where non-primitive arguments are stored.\r\n   */\r\n  o: null | WeakMap<Function | Object, CacheNode<T>>\r\n  /**\r\n   * Primitive cache, a regular Map where primitive arguments are stored.\r\n   */\r\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>\r\n}\r\n\r\ninterface TerminatedCacheNode<T> {\r\n  /**\r\n   * Status, represents whether the cached computation returned a value or threw an error.\r\n   */\r\n  s: 1\r\n  /**\r\n   * Value, either the cached result or an error, depending on status.\r\n   */\r\n  v: T\r\n  /**\r\n   * Object cache, a `WeakMap` where non-primitive arguments are stored.\r\n   */\r\n  o: null | WeakMap<Function | Object, CacheNode<T>>\r\n  /**\r\n   * Primitive cache, a regular `Map` where primitive arguments are stored.\r\n   */\r\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>\r\n}\r\n\r\ntype CacheNode<T> = TerminatedCacheNode<T> | UnterminatedCacheNode<T>\r\n\r\nfunction createCacheNode<T>(): CacheNode<T> {\r\n  return {\r\n    s: UNTERMINATED,\r\n    v: undefined,\r\n    o: null,\r\n    p: null\r\n  }\r\n}\r\n\r\n/**\r\n * Configuration options for a memoization function utilizing `WeakMap` for\r\n * its caching mechanism.\r\n *\r\n * @template Result - The type of the return value of the memoized function.\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport interface WeakMapMemoizeOptions<Result = any> {\r\n  /**\r\n   * If provided, used to compare a newly generated output value against previous values in the cache.\r\n   * If a match is found, the old value is returned. This addresses the common\r\n   * ```ts\r\n   * todos.map(todo => todo.id)\r\n   * ```\r\n   * use case, where an update to another field in the original data causes a recalculation\r\n   * due to changed references, but the output is still effectively the same.\r\n   *\r\n   * @since 5.0.0\r\n   */\r\n  resultEqualityCheck?: EqualityFn<Result>\r\n}\r\n\r\n/**\r\n * Creates a tree of `WeakMap`-based cache nodes based on the identity of the\r\n * arguments it's been called with (in this case, the extracted values from your input selectors).\r\n * This allows `weakMapMemoize` to have an effectively infinite cache size.\r\n * Cache results will be kept in memory as long as references to the arguments still exist,\r\n * and then cleared out as the arguments are garbage-collected.\r\n *\r\n * __Design Tradeoffs for `weakMapMemoize`:__\r\n * - Pros:\r\n *   - It has an effectively infinite cache size, but you have no control over\r\n *   how long values are kept in cache as it's based on garbage collection and `WeakMap`s.\r\n * - Cons:\r\n *   - There's currently no way to alter the argument comparisons.\r\n *   They're based on strict reference equality.\r\n *   - It's roughly the same speed as `lruMemoize`, although likely a fraction slower.\r\n *\r\n * __Use Cases for `weakMapMemoize`:__\r\n * - This memoizer is likely best used for cases where you need to call the\r\n * same selector instance with many different arguments, such as a single\r\n * selector instance that is used in a list item component and called with\r\n * item IDs like:\r\n *   ```ts\r\n *   useSelector(state => selectSomeData(state, props.category))\r\n *   ```\r\n * @param func - The function to be memoized.\r\n * @returns A memoized function with a `.clearCache()` method attached.\r\n *\r\n * @example\r\n * <caption>Using `createSelector`</caption>\r\n * ```ts\r\n * import { createSelector, weakMapMemoize } from 'reselect'\r\n *\r\n * interface RootState {\r\n *   items: { id: number; category: string; name: string }[]\r\n * }\r\n *\r\n * const selectItemsByCategory = createSelector(\r\n *   [\r\n *     (state: RootState) => state.items,\r\n *     (state: RootState, category: string) => category\r\n *   ],\r\n *   (items, category) => items.filter(item => item.category === category),\r\n *   {\r\n *     memoize: weakMapMemoize,\r\n *     argsMemoize: weakMapMemoize\r\n *   }\r\n * )\r\n * ```\r\n *\r\n * @example\r\n * <caption>Using `createSelectorCreator`</caption>\r\n * ```ts\r\n * import { createSelectorCreator, weakMapMemoize } from 'reselect'\r\n *\r\n * const createSelectorWeakMap = createSelectorCreator({ memoize: weakMapMemoize, argsMemoize: weakMapMemoize })\r\n *\r\n * const selectItemsByCategory = createSelectorWeakMap(\r\n *   [\r\n *     (state: RootState) => state.items,\r\n *     (state: RootState, category: string) => category\r\n *   ],\r\n *   (items, category) => items.filter(item => item.category === category)\r\n * )\r\n * ```\r\n *\r\n * @template Func - The type of the function that is memoized.\r\n *\r\n * @see {@link https://reselect.js.org/api/weakMapMemoize `weakMapMemoize`}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n * @experimental\r\n */\r\nexport function weakMapMemoize<Func extends AnyFunction>(\r\n  func: Func,\r\n  options: WeakMapMemoizeOptions<ReturnType<Func>> = {}\r\n) {\r\n  let fnNode = createCacheNode()\r\n  const { resultEqualityCheck } = options\r\n\r\n  let lastResult: WeakRef<object> | undefined\r\n\r\n  let resultsCount = 0\r\n\r\n  function memoized() {\r\n    let cacheNode = fnNode\r\n    const { length } = arguments\r\n    for (let i = 0, l = length; i < l; i++) {\r\n      const arg = arguments[i]\r\n      if (\r\n        typeof arg === 'function' ||\r\n        (typeof arg === 'object' && arg !== null)\r\n      ) {\r\n        // Objects go into a WeakMap\r\n        let objectCache = cacheNode.o\r\n        if (objectCache === null) {\r\n          cacheNode.o = objectCache = new WeakMap()\r\n        }\r\n        const objectNode = objectCache.get(arg)\r\n        if (objectNode === undefined) {\r\n          cacheNode = createCacheNode()\r\n          objectCache.set(arg, cacheNode)\r\n        } else {\r\n          cacheNode = objectNode\r\n        }\r\n      } else {\r\n        // Primitives go into a regular Map\r\n        let primitiveCache = cacheNode.p\r\n        if (primitiveCache === null) {\r\n          cacheNode.p = primitiveCache = new Map()\r\n        }\r\n        const primitiveNode = primitiveCache.get(arg)\r\n        if (primitiveNode === undefined) {\r\n          cacheNode = createCacheNode()\r\n          primitiveCache.set(arg, cacheNode)\r\n        } else {\r\n          cacheNode = primitiveNode\r\n        }\r\n      }\r\n    }\r\n\r\n    const terminatedNode = cacheNode as unknown as TerminatedCacheNode<any>\r\n\r\n    let result\r\n\r\n    if (cacheNode.s === TERMINATED) {\r\n      result = cacheNode.v\r\n    } else {\r\n      // Allow errors to propagate\r\n      result = func.apply(null, arguments as unknown as any[])\r\n      resultsCount++\r\n\r\n      if (resultEqualityCheck) {\r\n        const lastResultValue = lastResult?.deref?.() ?? lastResult\r\n\r\n        if (\r\n          lastResultValue != null &&\r\n          resultEqualityCheck(lastResultValue as ReturnType<Func>, result)\r\n        ) {\r\n          result = lastResultValue\r\n\r\n          resultsCount !== 0 && resultsCount--\r\n        }\r\n\r\n        const needsWeakRef =\r\n          (typeof result === 'object' && result !== null) ||\r\n          typeof result === 'function'\r\n\r\n        lastResult = needsWeakRef ? new Ref(result) : result\r\n      }\r\n    }\r\n\r\n    terminatedNode.s = TERMINATED\r\n\r\n    terminatedNode.v = result\r\n    return result\r\n  }\r\n\r\n  memoized.clearCache = () => {\r\n    fnNode = createCacheNode()\r\n    memoized.resetResultsCount()\r\n  }\r\n\r\n  memoized.resultsCount = () => resultsCount\r\n\r\n  memoized.resetResultsCount = () => {\r\n    resultsCount = 0\r\n  }\r\n\r\n  return memoized as Func & Simplify<DefaultMemoizeFields>\r\n}\r\n","import { weakMapMemoize } from './weakMapMemoize'\r\n\r\nimport type {\r\n  Combiner,\r\n  CreateSelectorOptions,\r\n  DropFirstParameter,\r\n  ExtractMemoizerFields,\r\n  GetParamsFromSelectors,\r\n  GetStateFromSelectors,\r\n  InterruptRecursion,\r\n  OutputSelector,\r\n  Selector,\r\n  SelectorArray,\r\n  SetRequired,\r\n  Simplify,\r\n  UnknownMemoizer\r\n} from './types'\r\n\r\nimport {\r\n  assertIsFunction,\r\n  collectInputSelectorResults,\r\n  ensureIsArray,\r\n  getDependencies,\r\n  getDevModeChecksExecutionInfo\r\n} from './utils'\r\n\r\n/**\r\n * An instance of `createSelector`, customized with a given memoize implementation.\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n * @template StateType - The type of state that the selectors created with this selector creator will operate on.\r\n *\r\n * @public\r\n */\r\nexport interface CreateSelectorFunction<\r\n  MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n  ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n  StateType = any\r\n> {\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param createSelectorArgs - An arbitrary number of input selectors as separate inline arguments and a `combiner` function.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors as an array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createselector `createSelector`}\r\n   */\r\n  <InputSelectors extends SelectorArray<StateType>, Result>(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: InputSelectors,\r\n      combiner: Combiner<InputSelectors, Result>\r\n    ]\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param createSelectorArgs - An arbitrary number of input selectors as separate inline arguments, a `combiner` function and an `options` object.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors as an array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createselector `createSelector`}\r\n   */\r\n  <\r\n    InputSelectors extends SelectorArray<StateType>,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: InputSelectors,\r\n      combiner: Combiner<InputSelectors, Result>,\r\n      createSelectorOptions: Simplify<\r\n        CreateSelectorOptions<\r\n          MemoizeFunction,\r\n          ArgsMemoizeFunction,\r\n          OverrideMemoizeFunction,\r\n          OverrideArgsMemoizeFunction\r\n        >\r\n      >\r\n    ]\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    OverrideMemoizeFunction,\r\n    OverrideArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param inputSelectors - An array of input selectors.\r\n   * @param combiner - A function that Combines the input selectors and returns an output selector. Otherwise known as the result function.\r\n   * @param createSelectorOptions - An optional options object that allows for further customization per selector.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createselector `createSelector`}\r\n   */\r\n  <\r\n    InputSelectors extends SelectorArray<StateType>,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    inputSelectors: [...InputSelectors],\r\n    combiner: Combiner<InputSelectors, Result>,\r\n    createSelectorOptions?: Simplify<\r\n      CreateSelectorOptions<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction,\r\n        OverrideMemoizeFunction,\r\n        OverrideArgsMemoizeFunction\r\n      >\r\n    >\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    OverrideMemoizeFunction,\r\n    OverrideArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a \"pre-typed\" version of {@linkcode createSelector createSelector}\r\n   * where the `state` type is predefined.\r\n   *\r\n   * This allows you to set the `state` type once, eliminating the need to\r\n   * specify it with every {@linkcode createSelector createSelector} call.\r\n   *\r\n   * @returns A pre-typed `createSelector` with the state type already defined.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * import { createSelector } from 'reselect'\r\n   *\r\n   * export interface RootState {\r\n   *   todos: { id: number; completed: boolean }[]\r\n   *   alerts: { id: number; read: boolean }[]\r\n   * }\r\n   *\r\n   * export const createAppSelector = createSelector.withTypes<RootState>()\r\n   *\r\n   * const selectTodoIds = createAppSelector(\r\n   *   [\r\n   *     // Type of `state` is set to `RootState`, no need to manually set the type\r\n   *     state => state.todos\r\n   *   ],\r\n   *   todos => todos.map(({ id }) => id)\r\n   * )\r\n   * ```\r\n   * @template OverrideStateType - The specific type of state used by all selectors created with this selector creator.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createselector#defining-a-pre-typed-createselector `createSelector.withTypes`}\r\n   *\r\n   * @since 5.1.0\r\n   */\r\n  withTypes: <OverrideStateType extends StateType>() => CreateSelectorFunction<\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction,\r\n    OverrideStateType\r\n  >\r\n}\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization function\r\n * and options for customizing memoization behavior.\r\n *\r\n * @param options - An options object containing the `memoize` function responsible for memoizing the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). It also provides additional options for customizing memoization. While the `memoize` property is mandatory, the rest are optional.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @example\r\n * ```ts\r\n * const customCreateSelector = createSelectorCreator({\r\n *   memoize: customMemoize, // Function to be used to memoize `resultFunc`\r\n *   memoizeOptions: [memoizeOption1, memoizeOption2], // Options passed to `customMemoize` as the second argument onwards\r\n *   argsMemoize: customArgsMemoize, // Function to be used to memoize the selector's arguments\r\n *   argsMemoizeOptions: [argsMemoizeOption1, argsMemoizeOption2] // Options passed to `customArgsMemoize` as the second argument onwards\r\n * })\r\n *\r\n * const customSelector = customCreateSelector(\r\n *   [inputSelector1, inputSelector2],\r\n *   resultFunc // `resultFunc` will be passed as the first argument to `customMemoize`\r\n * )\r\n *\r\n * customSelector(\r\n *   ...selectorArgs // Will be memoized by `customArgsMemoize`\r\n * )\r\n * ```\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelectorCreator#using-options-since-500 `createSelectorCreator`}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport function createSelectorCreator<\r\n  MemoizeFunction extends UnknownMemoizer,\r\n  ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n>(\r\n  options: Simplify<\r\n    SetRequired<\r\n      CreateSelectorOptions<\r\n        typeof weakMapMemoize,\r\n        typeof weakMapMemoize,\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction\r\n      >,\r\n      'memoize'\r\n    >\r\n  >\r\n): CreateSelectorFunction<MemoizeFunction, ArgsMemoizeFunction>\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization function\r\n * and options for customizing memoization behavior.\r\n *\r\n * @param memoize - The `memoize` function responsible for memoizing the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @param memoizeOptionsFromArgs - Optional configuration options for the memoization function. These options are then passed to the memoize function as the second argument onwards.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @example\r\n * ```ts\r\n * const customCreateSelector = createSelectorCreator(customMemoize, // Function to be used to memoize `resultFunc`\r\n *   option1, // Will be passed as second argument to `customMemoize`\r\n *   option2, // Will be passed as third argument to `customMemoize`\r\n *   option3 // Will be passed as fourth argument to `customMemoize`\r\n * )\r\n *\r\n * const customSelector = customCreateSelector(\r\n *   [inputSelector1, inputSelector2],\r\n *   resultFunc // `resultFunc` will be passed as the first argument to `customMemoize`\r\n * )\r\n * ```\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelectorCreator#using-memoize-and-memoizeoptions `createSelectorCreator`}\r\n *\r\n * @public\r\n */\r\nexport function createSelectorCreator<MemoizeFunction extends UnknownMemoizer>(\r\n  memoize: MemoizeFunction,\r\n  ...memoizeOptionsFromArgs: DropFirstParameter<MemoizeFunction>\r\n): CreateSelectorFunction<MemoizeFunction>\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization\r\n * function and options for customizing memoization behavior.\r\n *\r\n * @param memoizeOrOptions - Either A `memoize` function or an `options` object containing the `memoize` function.\r\n * @param memoizeOptionsFromArgs - Optional configuration options for the memoization function. These options are then passed to the memoize function as the second argument onwards.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n * @template MemoizeOrOptions - The type of the first argument. It can either be a `memoize` function or an `options` object containing the `memoize` function.\r\n */\r\nexport function createSelectorCreator<\r\n  MemoizeFunction extends UnknownMemoizer,\r\n  ArgsMemoizeFunction extends UnknownMemoizer,\r\n  MemoizeOrOptions extends\r\n    | MemoizeFunction\r\n    | SetRequired<\r\n        CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n        'memoize'\r\n      >\r\n>(\r\n  memoizeOrOptions: MemoizeOrOptions,\r\n  ...memoizeOptionsFromArgs: MemoizeOrOptions extends SetRequired<\r\n    CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n    'memoize'\r\n  >\r\n    ? never\r\n    : DropFirstParameter<MemoizeFunction>\r\n) {\r\n  /** options initially passed into `createSelectorCreator`. */\r\n  const createSelectorCreatorOptions: SetRequired<\r\n    CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n    'memoize'\r\n  > = typeof memoizeOrOptions === 'function'\r\n    ? {\r\n        memoize: memoizeOrOptions as MemoizeFunction,\r\n        memoizeOptions: memoizeOptionsFromArgs\r\n      }\r\n    : memoizeOrOptions\r\n\r\n  const createSelector = <\r\n    InputSelectors extends SelectorArray,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: [...InputSelectors],\r\n      combiner: Combiner<InputSelectors, Result>,\r\n      createSelectorOptions?: CreateSelectorOptions<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction,\r\n        OverrideMemoizeFunction,\r\n        OverrideArgsMemoizeFunction\r\n      >\r\n    ]\r\n  ) => {\r\n    let recomputations = 0\r\n    let dependencyRecomputations = 0\r\n    let lastResult: Result\r\n\r\n    // Due to the intricacies of rest params, we can't do an optional arg after `...createSelectorArgs`.\r\n    // So, start by declaring the default value here.\r\n    // (And yes, the words 'memoize' and 'options' appear too many times in this next sequence.)\r\n    let directlyPassedOptions: CreateSelectorOptions<\r\n      MemoizeFunction,\r\n      ArgsMemoizeFunction,\r\n      OverrideMemoizeFunction,\r\n      OverrideArgsMemoizeFunction\r\n    > = {}\r\n\r\n    // Normally, the result func or \"combiner\" is the last arg\r\n    let resultFunc = createSelectorArgs.pop() as\r\n      | Combiner<InputSelectors, Result>\r\n      | CreateSelectorOptions<\r\n          MemoizeFunction,\r\n          ArgsMemoizeFunction,\r\n          OverrideMemoizeFunction,\r\n          OverrideArgsMemoizeFunction\r\n        >\r\n\r\n    // If the result func is actually an _object_, assume it's our options object\r\n    if (typeof resultFunc === 'object') {\r\n      directlyPassedOptions = resultFunc\r\n      // and pop the real result func off\r\n      resultFunc = createSelectorArgs.pop() as Combiner<InputSelectors, Result>\r\n    }\r\n\r\n    assertIsFunction(\r\n      resultFunc,\r\n      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`\r\n    )\r\n\r\n    // Determine which set of options we're using. Prefer options passed directly,\r\n    // but fall back to options given to `createSelectorCreator`.\r\n    const combinedOptions = {\r\n      ...createSelectorCreatorOptions,\r\n      ...directlyPassedOptions\r\n    }\r\n\r\n    const {\r\n      memoize,\r\n      memoizeOptions = [],\r\n      argsMemoize = weakMapMemoize,\r\n      argsMemoizeOptions = [],\r\n      devModeChecks = {}\r\n    } = combinedOptions\r\n\r\n    // Simplifying assumption: it's unlikely that the first options arg of the provided memoizer\r\n    // is an array. In most libs I've looked at, it's an equality function or options object.\r\n    // Based on that, if `memoizeOptions` _is_ an array, we assume it's a full\r\n    // user-provided array of options. Otherwise, it must be just the _first_ arg, and so\r\n    // we wrap it in an array so we can apply it.\r\n    const finalMemoizeOptions = ensureIsArray(memoizeOptions)\r\n    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions)\r\n    const dependencies = getDependencies(createSelectorArgs) as InputSelectors\r\n\r\n    const memoizedResultFunc = memoize(function recomputationWrapper() {\r\n      recomputations++\r\n      // apply arguments instead of spreading for performance.\r\n      // @ts-ignore\r\n      return (resultFunc as Combiner<InputSelectors, Result>).apply(\r\n        null,\r\n        arguments as unknown as Parameters<Combiner<InputSelectors, Result>>\r\n      )\r\n    }, ...finalMemoizeOptions) as Combiner<InputSelectors, Result> &\r\n      ExtractMemoizerFields<OverrideMemoizeFunction>\r\n\r\n    let firstRun = true\r\n\r\n    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\r\n    const selector = argsMemoize(function dependenciesChecker() {\r\n      dependencyRecomputations++\r\n      /** Return values of input selectors which the `resultFunc` takes as arguments. */\r\n      const inputSelectorResults = collectInputSelectorResults(\r\n        dependencies,\r\n        arguments\r\n      )\r\n\r\n      // apply arguments instead of spreading for performance.\r\n      // @ts-ignore\r\n      lastResult = memoizedResultFunc.apply(null, inputSelectorResults)\r\n\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        const { identityFunctionCheck, inputStabilityCheck } =\r\n          getDevModeChecksExecutionInfo(firstRun, devModeChecks)\r\n        if (identityFunctionCheck.shouldRun) {\r\n          identityFunctionCheck.run(\r\n            resultFunc as Combiner<InputSelectors, Result>,\r\n            inputSelectorResults,\r\n            lastResult\r\n          )\r\n        }\r\n\r\n        if (inputStabilityCheck.shouldRun) {\r\n          // make a second copy of the params, to check if we got the same results\r\n          const inputSelectorResultsCopy = collectInputSelectorResults(\r\n            dependencies,\r\n            arguments\r\n          )\r\n\r\n          inputStabilityCheck.run(\r\n            { inputSelectorResults, inputSelectorResultsCopy },\r\n            { memoize, memoizeOptions: finalMemoizeOptions },\r\n            arguments\r\n          )\r\n        }\r\n\r\n        if (firstRun) firstRun = false\r\n      }\r\n\r\n      return lastResult\r\n    }, ...finalArgsMemoizeOptions) as unknown as Selector<\r\n      GetStateFromSelectors<InputSelectors>,\r\n      Result,\r\n      GetParamsFromSelectors<InputSelectors>\r\n    > &\r\n      ExtractMemoizerFields<OverrideArgsMemoizeFunction>\r\n\r\n    return Object.assign(selector, {\r\n      resultFunc,\r\n      memoizedResultFunc,\r\n      dependencies,\r\n      dependencyRecomputations: () => dependencyRecomputations,\r\n      resetDependencyRecomputations: () => {\r\n        dependencyRecomputations = 0\r\n      },\r\n      lastResult: () => lastResult,\r\n      recomputations: () => recomputations,\r\n      resetRecomputations: () => {\r\n        recomputations = 0\r\n      },\r\n      memoize,\r\n      argsMemoize\r\n    }) as OutputSelector<\r\n      InputSelectors,\r\n      Result,\r\n      OverrideMemoizeFunction,\r\n      OverrideArgsMemoizeFunction\r\n    >\r\n  }\r\n\r\n  Object.assign(createSelector, {\r\n    withTypes: () => createSelector\r\n  })\r\n\r\n  return createSelector as CreateSelectorFunction<\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  >\r\n}\r\n\r\n/**\r\n * Accepts one or more \"input selectors\" (either as separate arguments or a single array),\r\n * a single \"result function\" / \"combiner\", and an optional options object, and\r\n * generates a memoized selector function.\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelector `createSelector`}\r\n *\r\n * @public\r\n */\r\nexport const createSelector =\r\n  /* #__PURE__ */ createSelectorCreator(weakMapMemoize)\r\n","import { createSelector } from './createSelectorCreator'\r\n\r\nimport type { CreateSelectorFunction } from './createSelectorCreator'\r\nimport type {\r\n  InterruptRecursion,\r\n  ObjectValuesToTuple,\r\n  OutputSelector,\r\n  Selector,\r\n  Simplify,\r\n  UnknownMemoizer\r\n} from './types'\r\nimport { assertIsObject } from './utils'\r\nimport type { weakMapMemoize } from './weakMapMemoize'\r\n\r\n/**\r\n * Represents a mapping of selectors to their return types.\r\n *\r\n * @template TObject - An object type where each property is a selector function.\r\n *\r\n * @public\r\n */\r\nexport type SelectorResultsMap<TObject extends SelectorsObject> = {\r\n  [Key in keyof TObject]: ReturnType<TObject[Key]>\r\n}\r\n\r\n/**\r\n * Represents a mapping of selectors for each key in a given root state.\r\n *\r\n * This type is a utility that takes a root state object type and\r\n * generates a corresponding set of selectors. Each selector is associated\r\n * with a key in the root state, allowing for the selection\r\n * of specific parts of the state.\r\n *\r\n * @template RootState - The type of the root state object.\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport type RootStateSelectors<RootState = any> = {\r\n  [Key in keyof RootState]: Selector<RootState, RootState[Key], []>\r\n}\r\n\r\n/**\r\n * @deprecated Please use {@linkcode StructuredSelectorCreator.withTypes createStructuredSelector.withTypes<RootState>()} instead. This type will be removed in the future.\r\n * @template RootState - The type of the root state object.\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport type TypedStructuredSelectorCreator<RootState = any> =\r\n  /**\r\n   * A convenience function that simplifies returning an object\r\n   * made up of selector results.\r\n   *\r\n   * @param inputSelectorsObject - A key value pair consisting of input selectors.\r\n   * @param selectorCreator - A custom selector creator function. It defaults to `createSelector`.\r\n   * @returns A memoized structured selector.\r\n   *\r\n   * @example\r\n   * <caption>Modern Use Case</caption>\r\n   * ```ts\r\n   * import { createSelector, createStructuredSelector } from 'reselect'\r\n   *\r\n   * interface RootState {\r\n   *   todos: {\r\n   *     id: number\r\n   *     completed: boolean\r\n   *     title: string\r\n   *     description: string\r\n   *   }[]\r\n   *   alerts: { id: number; read: boolean }[]\r\n   * }\r\n   *\r\n   * // This:\r\n   * const structuredSelector = createStructuredSelector(\r\n   *   {\r\n   *     todos: (state: RootState) => state.todos,\r\n   *     alerts: (state: RootState) => state.alerts,\r\n   *     todoById: (state: RootState, id: number) => state.todos[id]\r\n   *   },\r\n   *   createSelector\r\n   * )\r\n   *\r\n   * // Is essentially the same as this:\r\n   * const selector = createSelector(\r\n   *   [\r\n   *     (state: RootState) => state.todos,\r\n   *     (state: RootState) => state.alerts,\r\n   *     (state: RootState, id: number) => state.todos[id]\r\n   *   ],\r\n   *   (todos, alerts, todoById) => {\r\n   *     return {\r\n   *       todos,\r\n   *       alerts,\r\n   *       todoById\r\n   *     }\r\n   *   }\r\n   * )\r\n   * ```\r\n   *\r\n   * @example\r\n   * <caption>In your component:</caption>\r\n   * ```tsx\r\n   * import type { RootState } from 'createStructuredSelector/modernUseCase'\r\n   * import { structuredSelector } from 'createStructuredSelector/modernUseCase'\r\n   * import type { FC } from 'react'\r\n   * import { useSelector } from 'react-redux'\r\n   *\r\n   * interface Props {\r\n   *   id: number\r\n   * }\r\n   *\r\n   * const MyComponent: FC<Props> = ({ id }) => {\r\n   *   const { todos, alerts, todoById } = useSelector((state: RootState) =>\r\n   *     structuredSelector(state, id)\r\n   *   )\r\n   *\r\n   *   return (\r\n   *     <div>\r\n   *       Next to do is:\r\n   *       <h2>{todoById.title}</h2>\r\n   *       <p>Description: {todoById.description}</p>\r\n   *       <ul>\r\n   *         <h3>All other to dos:</h3>\r\n   *         {todos.map(todo => (\r\n   *           <li key={todo.id}>{todo.title}</li>\r\n   *         ))}\r\n   *       </ul>\r\n   *     </div>\r\n   *   )\r\n   * }\r\n   * ```\r\n   *\r\n   * @example\r\n   * <caption>Simple Use Case</caption>\r\n   * ```ts\r\n   * const selectA = state => state.a\r\n   * const selectB = state => state.b\r\n   *\r\n   * // The result function in the following selector\r\n   * // is simply building an object from the input selectors\r\n   * const structuredSelector = createSelector(selectA, selectB, (a, b) => ({\r\n   *   a,\r\n   *   b\r\n   * }))\r\n   *\r\n   * const result = structuredSelector({ a: 1, b: 2 }) // will produce { x: 1, y: 2 }\r\n   * ```\r\n   *\r\n   * @template InputSelectorsObject - The shape of the input selectors object.\r\n   * @template MemoizeFunction - The type of the memoize function that is used to create the structured selector. It defaults to `weakMapMemoize`.\r\n   * @template ArgsMemoizeFunction - The type of the of the memoize function that is used to memoize the arguments passed into the generated structured selector. It defaults to `weakMapMemoize`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\r\n   */\r\n  <\r\n    InputSelectorsObject extends RootStateSelectors<RootState> = RootStateSelectors<RootState>,\r\n    MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n    ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n  >(\r\n    inputSelectorsObject: InputSelectorsObject,\r\n    selectorCreator?: CreateSelectorFunction<\r\n      MemoizeFunction,\r\n      ArgsMemoizeFunction\r\n    >\r\n  ) => OutputSelector<\r\n    ObjectValuesToTuple<InputSelectorsObject>,\r\n    Simplify<SelectorResultsMap<InputSelectorsObject>>,\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n/**\r\n * Represents an object where each property is a selector function.\r\n *\r\n * @template StateType - The type of state that all the selectors operate on.\r\n *\r\n * @public\r\n */\r\nexport type SelectorsObject<StateType = any> = Record<\r\n  string,\r\n  Selector<StateType>\r\n>\r\n\r\n/**\r\n * It provides a way to create structured selectors.\r\n * The structured selector can take multiple input selectors\r\n * and map their output to an object with specific keys.\r\n *\r\n * @template StateType - The type of state that the structured selectors created with this structured selector creator will operate on.\r\n *\r\n * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\r\n *\r\n * @public\r\n */\r\nexport interface StructuredSelectorCreator<StateType = any> {\r\n  /**\r\n   * A convenience function that simplifies returning an object\r\n   * made up of selector results.\r\n   *\r\n   * @param inputSelectorsObject - A key value pair consisting of input selectors.\r\n   * @param selectorCreator - A custom selector creator function. It defaults to `createSelector`.\r\n   * @returns A memoized structured selector.\r\n   *\r\n   * @example\r\n   * <caption>Modern Use Case</caption>\r\n   * ```ts\r\n   * import { createSelector, createStructuredSelector } from 'reselect'\r\n   *\r\n   * interface RootState {\r\n   *   todos: {\r\n   *     id: number\r\n   *     completed: boolean\r\n   *     title: string\r\n   *     description: string\r\n   *   }[]\r\n   *   alerts: { id: number; read: boolean }[]\r\n   * }\r\n   *\r\n   * // This:\r\n   * const structuredSelector = createStructuredSelector(\r\n   *   {\r\n   *     todos: (state: RootState) => state.todos,\r\n   *     alerts: (state: RootState) => state.alerts,\r\n   *     todoById: (state: RootState, id: number) => state.todos[id]\r\n   *   },\r\n   *   createSelector\r\n   * )\r\n   *\r\n   * // Is essentially the same as this:\r\n   * const selector = createSelector(\r\n   *   [\r\n   *     (state: RootState) => state.todos,\r\n   *     (state: RootState) => state.alerts,\r\n   *     (state: RootState, id: number) => state.todos[id]\r\n   *   ],\r\n   *   (todos, alerts, todoById) => {\r\n   *     return {\r\n   *       todos,\r\n   *       alerts,\r\n   *       todoById\r\n   *     }\r\n   *   }\r\n   * )\r\n   * ```\r\n   *\r\n   * @example\r\n   * <caption>In your component:</caption>\r\n   * ```tsx\r\n   * import type { RootState } from 'createStructuredSelector/modernUseCase'\r\n   * import { structuredSelector } from 'createStructuredSelector/modernUseCase'\r\n   * import type { FC } from 'react'\r\n   * import { useSelector } from 'react-redux'\r\n   *\r\n   * interface Props {\r\n   *   id: number\r\n   * }\r\n   *\r\n   * const MyComponent: FC<Props> = ({ id }) => {\r\n   *   const { todos, alerts, todoById } = useSelector((state: RootState) =>\r\n   *     structuredSelector(state, id)\r\n   *   )\r\n   *\r\n   *   return (\r\n   *     <div>\r\n   *       Next to do is:\r\n   *       <h2>{todoById.title}</h2>\r\n   *       <p>Description: {todoById.description}</p>\r\n   *       <ul>\r\n   *         <h3>All other to dos:</h3>\r\n   *         {todos.map(todo => (\r\n   *           <li key={todo.id}>{todo.title}</li>\r\n   *         ))}\r\n   *       </ul>\r\n   *     </div>\r\n   *   )\r\n   * }\r\n   * ```\r\n   *\r\n   * @example\r\n   * <caption>Simple Use Case</caption>\r\n   * ```ts\r\n   * const selectA = state => state.a\r\n   * const selectB = state => state.b\r\n   *\r\n   * // The result function in the following selector\r\n   * // is simply building an object from the input selectors\r\n   * const structuredSelector = createSelector(selectA, selectB, (a, b) => ({\r\n   *   a,\r\n   *   b\r\n   * }))\r\n   *\r\n   * const result = structuredSelector({ a: 1, b: 2 }) // will produce { x: 1, y: 2 }\r\n   * ```\r\n   *\r\n   * @template InputSelectorsObject - The shape of the input selectors object.\r\n   * @template MemoizeFunction - The type of the memoize function that is used to create the structured selector. It defaults to `weakMapMemoize`.\r\n   * @template ArgsMemoizeFunction - The type of the of the memoize function that is used to memoize the arguments passed into the generated structured selector. It defaults to `weakMapMemoize`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\r\n   */\r\n  <\r\n    InputSelectorsObject extends SelectorsObject<StateType>,\r\n    MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n    ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n  >(\r\n    inputSelectorsObject: InputSelectorsObject,\r\n    selectorCreator?: CreateSelectorFunction<\r\n      MemoizeFunction,\r\n      ArgsMemoizeFunction\r\n    >\r\n  ): OutputSelector<\r\n    ObjectValuesToTuple<InputSelectorsObject>,\r\n    Simplify<SelectorResultsMap<InputSelectorsObject>>,\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a \"pre-typed\" version of\r\n   * {@linkcode createStructuredSelector createStructuredSelector}\r\n   * where the `state` type is predefined.\r\n   *\r\n   * This allows you to set the `state` type once, eliminating the need to\r\n   * specify it with every\r\n   * {@linkcode createStructuredSelector createStructuredSelector} call.\r\n   *\r\n   * @returns A pre-typed `createStructuredSelector` with the state type already defined.\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * import { createStructuredSelector } from 'reselect'\r\n   *\r\n   * export interface RootState {\r\n   *   todos: { id: number; completed: boolean }[]\r\n   *   alerts: { id: number; read: boolean }[]\r\n   * }\r\n   *\r\n   * export const createStructuredAppSelector =\r\n   *   createStructuredSelector.withTypes<RootState>()\r\n   *\r\n   * const structuredAppSelector = createStructuredAppSelector({\r\n   *   // Type of `state` is set to `RootState`, no need to manually set the type\r\n   *   todos: state => state.todos,\r\n   *   alerts: state => state.alerts,\r\n   *   todoById: (state, id: number) => state.todos[id]\r\n   * })\r\n   *\r\n   * ```\r\n   * @template OverrideStateType - The specific type of state used by all structured selectors created with this structured selector creator.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createstructuredselector#defining-a-pre-typed-createstructuredselector `createSelector.withTypes`}\r\n   *\r\n   * @since 5.1.0\r\n   */\r\n  withTypes: <\r\n    OverrideStateType extends StateType\r\n  >() => StructuredSelectorCreator<OverrideStateType>\r\n}\r\n\r\n/**\r\n * A convenience function that simplifies returning an object\r\n * made up of selector results.\r\n *\r\n * @param inputSelectorsObject - A key value pair consisting of input selectors.\r\n * @param selectorCreator - A custom selector creator function. It defaults to `createSelector`.\r\n * @returns A memoized structured selector.\r\n *\r\n * @example\r\n * <caption>Modern Use Case</caption>\r\n * ```ts\r\n * import { createSelector, createStructuredSelector } from 'reselect'\r\n *\r\n * interface RootState {\r\n *   todos: {\r\n *     id: number\r\n *     completed: boolean\r\n *     title: string\r\n *     description: string\r\n *   }[]\r\n *   alerts: { id: number; read: boolean }[]\r\n * }\r\n *\r\n * // This:\r\n * const structuredSelector = createStructuredSelector(\r\n *   {\r\n *     todos: (state: RootState) => state.todos,\r\n *     alerts: (state: RootState) => state.alerts,\r\n *     todoById: (state: RootState, id: number) => state.todos[id]\r\n *   },\r\n *   createSelector\r\n * )\r\n *\r\n * // Is essentially the same as this:\r\n * const selector = createSelector(\r\n *   [\r\n *     (state: RootState) => state.todos,\r\n *     (state: RootState) => state.alerts,\r\n *     (state: RootState, id: number) => state.todos[id]\r\n *   ],\r\n *   (todos, alerts, todoById) => {\r\n *     return {\r\n *       todos,\r\n *       alerts,\r\n *       todoById\r\n *     }\r\n *   }\r\n * )\r\n * ```\r\n *\r\n * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\r\n *\r\n * @public\r\n */\r\nexport const createStructuredSelector: StructuredSelectorCreator =\r\n  Object.assign(\r\n    <\r\n      InputSelectorsObject extends SelectorsObject,\r\n      MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n      ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n    >(\r\n      inputSelectorsObject: InputSelectorsObject,\r\n      selectorCreator: CreateSelectorFunction<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction\r\n      > = createSelector as CreateSelectorFunction<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction\r\n      >\r\n    ) => {\r\n      assertIsObject(\r\n        inputSelectorsObject,\r\n        'createStructuredSelector expects first argument to be an object ' +\r\n          `where each property is a selector, instead received a ${typeof inputSelectorsObject}`\r\n      )\r\n      const inputSelectorKeys = Object.keys(inputSelectorsObject)\r\n      const dependencies = inputSelectorKeys.map(\r\n        key => inputSelectorsObject[key]\r\n      )\r\n      const structuredSelector = selectorCreator(\r\n        dependencies,\r\n        (...inputSelectorResults: any[]) => {\r\n          return inputSelectorResults.reduce((composition, value, index) => {\r\n            composition[inputSelectorKeys[index]] = value\r\n            return composition\r\n          }, {})\r\n        }\r\n      )\r\n      return structuredSelector\r\n    },\r\n    { withTypes: () => createStructuredSelector }\r\n  ) as StructuredSelectorCreator\r\n","import {createSelector} from \"reselect\";\n\n// Пример примитивного селектора\nexport const getUsers = (state) => {\n    return state.usersPage.users;\n};\n// Если нужны какие-то вычисления в селекторе\n// Если надо произвести какую-то операцию над получаемыми данными, то используем библиотеку reselect\nexport const getUsersReselectLib = createSelector(getUsers, (users)=>{\n    return users;\n});\n\n\nexport const getPageSize = (state) => {\n    return state.usersPage.pageSize;\n};\n\n\nexport const getTotalUsersCount = (state) => {\n    return state.usersPage.totalUsersCount;\n};\n\n\nexport const getCurrentPage = (state) => {\n    return state.usersPage.currentPage;\n};\n\n\nexport const getFetchingStatus = (state) => {\n    return state.usersPage.isFetching;\n};\n\nexport const getFollowingStatus = (state) => {\n    return state.usersPage.followingInProcess;\n};","import React from \"react\";\nimport {connect} from \"react-redux\";\n\nimport {\n    followAC,\n    setCurrentPageAC,\n    setFollowingStatusAC,\n    unfollowAC,\n    getUsersThunkCreator,\n    followUserThunkCreator,\n    unfollowUserThunkCreator\n} from \"../../redux/users-reducer\";\n\nimport UsersInContainer from \"./UsersInContainer\";\nimport {getCurrentPage, getFetchingStatus, getFollowingStatus, getPageSize, getTotalUsersCount, getUsers, getUsersReselectLib} from \"../../redux/users-selectors\";\n\nclass UsersContainerClass extends React.Component {\n    componentDidMount() {\n        this.props.getUsersThunk(this.props.currentPage, this.props.pageSize);\n    }\n\n    onPageChange = (pageNumber) => {\n        this.props.setCurrentPage(pageNumber);\n        this.props.getUsersThunk(pageNumber, this.props.pageSize);\n    }\n\n    render() {\n        return <UsersInContainer totalUsersCount={this.props.totalUsersCount}\n                          pageSize={this.props.pageSize}\n                          users={this.props.users}\n                          currentPage={this.props.currentPage}\n                          onPageChange={this.onPageChange}\n                          follow={this.props.follow}\n                          unfollow={this.props.unfollow}\n                          isFetching={this.props.isFetching}\n                          setFollowingStatus={this.props.setFollowingStatus}\n                          followingInProcess={this.props.followingInProcess}\n                          followUserThunk={this.props.followUserThunk}\n                          unfollowUserThunk={this.props.unfollowUserThunk}\n        />;\n    }\n}\n\n// С помощью селекторов\nconst mapStateToProps = (state) => {\n    return {\n       // users: getUsers(state),\n        users: getUsersReselectLib(state),\n        pageSize: getPageSize(state),\n        totalUsersCount: getTotalUsersCount(state),\n        currentPage: getCurrentPage(state),\n        isFetching: getFetchingStatus(state),\n        followingInProcess: getFollowingStatus(state)\n    }\n};\n// Без селекторов\n// const mapStateToProps = (state) => {\n//     return {\n//         users: state.usersPage.users,\n//         pageSize: state.usersPage.pageSize,\n//         totalUsersCount: state.usersPage.totalUsersCount,\n//         currentPage: state.usersPage.currentPage,\n//         isFetching: state.usersPage.isFetching,\n//         followingInProcess: state.usersPage.followingInProcess\n//     }\n// };\n\nconst mapDispatchToProps = (dispatch)=>{\n    return {\n        follow: (userId) => {\n            dispatch(followAC(userId));\n        },\n        unfollow: (userId) => {\n            dispatch(unfollowAC(userId));\n        },\n        setCurrentPage: (currentPage)=>{\n            dispatch(setCurrentPageAC(currentPage))\n        },\n        setFollowingStatus: (fetchingStatus, userId)=>{\n            dispatch(setFollowingStatusAC(fetchingStatus, userId));\n        },\n        getUsersThunk: (currentPage, pageSize)=>{\n            dispatch(getUsersThunkCreator(currentPage, pageSize));\n        },\n        followUserThunk: (userId)=>{\n            dispatch(followUserThunkCreator(userId));\n        },\n        unfollowUserThunk: (userId)=>{\n            dispatch(unfollowUserThunkCreator(userId));\n        }\n    }\n};\n\n\nexport default connect(mapStateToProps, mapDispatchToProps)(UsersContainerClass);\n","// extracted by mini-css-extract-plugin\nexport default {\"users_head\":\"Users_users_head__d4RQM\",\"user_wrap\":\"Users_user_wrap__C8aIv\",\"users_list\":\"Users_users_list__yqcvh\",\"users_list--loading\":\"Users_users_list--loading__aXAOR\"};"],"names":["props","startPage","Math","max","currentPage","endPage","min","itemsPerPage","pagesCount","pages","i","push","_jsxs","className","classes","pagination","children","_jsx","pagination__item","pagination__arrow","onClick","changePage","disabled","src","arrowNext","alt","map","page","index","user","NavLink","to","id","photos","small","userPhoto","followed","unfollowUser","unfollowUserThunk","followUser","followUserThunk","followingInProcess","some","name","status","ceil","totalUsersCount","pageSize","users_head","user_wrap","isFetching","users_list","users","User","follow","unfollow","setFollowingStatus","Loader","parent","Pagination","onPageChange","assertIsFunction","func","TypeError","arguments","length","undefined","ensureIsArray","item","Array","isArray","getDependencies","createSelectorArgs","dependencies","array","errorMessage","every","itemTypes","join","assertIsArrayOfFunctions","Symbol","Object","getPrototypeOf","Ref","WeakRef","constructor","value","deref","this","weakMapMemoize","options","fnNode","s","v","o","p","resultEqualityCheck","lastResult","resultsCount","memoized","cacheNode","l","arg","objectCache","WeakMap","objectNode","get","set","primitiveCache","Map","primitiveNode","terminatedNode","result","apply","lastResultValue","clearCache","resetResultsCount","createSelectorCreator","memoizeOrOptions","_len","memoizeOptionsFromArgs","_key2","createSelectorCreatorOptions","memoize","memoizeOptions","createSelector2","_len2","_key3","recomputations","dependencyRecomputations","directlyPassedOptions","resultFunc","pop","combinedOptions","argsMemoize","argsMemoizeOptions","devModeChecks","finalMemoizeOptions","finalArgsMemoizeOptions","memoizedResultFunc","selector","inputSelectorResults","inputSelectorArgs","collectInputSelectorResults","assign","resetDependencyRecomputations","resetRecomputations","withTypes","createSelector","createStructuredSelector","inputSelectorsObject","selectorCreator","object","assertIsObject","inputSelectorKeys","keys","structuredSelector","key","_len3","_key4","reduce","composition","getUsersReselectLib","state","usersPage","getPageSize","getTotalUsersCount","getCurrentPage","getFetchingStatus","getFollowingStatus","UsersContainerClass","React","pageNumber","setCurrentPage","getUsersThunk","componentDidMount","render","UsersInContainer","connect","dispatch","userId","followAC","unfollowAC","setCurrentPageAC","fetchingStatus","setFollowingStatusAC","getUsersThunkCreator","followUserThunkCreator","unfollowUserThunkCreator"],"sourceRoot":""}